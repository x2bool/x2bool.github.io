{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/sqlite-extensions-in-rust/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Sergey Khabibullin - blog"}},"markdownRemark":{"id":"aed3217f-255a-5e75-a54d-5ad6833e0452","excerpt":"This article explains how SQLite can be extended with Rust. In particular, it will outline SQLite’s mechanism called virtual tables and showcase how we can use…","html":"<p>This article explains how SQLite can be extended with Rust. In particular, it will outline SQLite’s mechanism called virtual tables and showcase how we can use it from Rust programming language.</p>\n<img src=\"/blog/sqlite-extensions-in-rust/dalle-rust-sqlite.png\" alt=\"Extending SQLite with Rust\" />\n<p>In the end, we will have a working extension that can be dynamically loaded and used from SQLite. This article does not claim to be an exhaustive guide about extending SQLite with Rust, but I hope the reader will have a basic understanding of how extensions work after reading it.</p>\n<p>We will be dealing with some amount of unsafe Rust code. There are frameworks that can be used to abstract away some unsafe code, but we’ll not use them because rust-bindgen will take care of generating the bindings for us, and we will only use unsafe in the relatively thin layer of code that connects SQLite and Rust.</p>\n<p>Processing Excel files with Rust won’t be covered. This task is delegated to excellent and easy to use <a href=\"https://github.com/tafia/calamine\">Calamine</a> library. I recommend reading their documentation.</p>\n<p>Also, I won’t post and explain every piece of code for obvious reasons, but, of course, everyone is welcome at <a href=\"https://github.com/x2bool/xlite\">GitHub</a>.</p>\n<h3>Objectives</h3>\n<p>Let’s say we have some useful data in Excel, and we would like to process it using SQL. One way of doing that would be importing data from a spreadsheet to some table inside SQLite. That is certainly a valid and useful approach: it’s possible to convert XLSX and XLS files to CSV and then import the CSV files for further processing.</p>\n<p>There is another way to approach this problem - virtual tables. The <a href=\"https://sqlite.org\">sqlite.org</a> site states: “The virtual table is an object that looks like any other table or view. But behind the scenes, queries and updates on a virtual table invoke callback methods of the virtual table object instead of reading and writing on the database file”. In other words, a virtual table is something that abstracts away some data source which could be used as a table.</p>\n<blockquote>\n<p>If it looks like a table, swims like a table, and quacks like a table, then it probably is a table</p>\n</blockquote>\n<p>There is already an implementation for CSV virtual tables. Let’s see what the typical usage of the CSV virtual table looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> VIRTUAL <span class=\"token keyword\">TABLE</span> csv_data <span class=\"token keyword\">USING</span> csv<span class=\"token punctuation\">(</span>\n    FILENAME<span class=\"token operator\">=</span><span class=\"token string\">'/path/to/file.csv'</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> csv_data<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Really simple and self-explanatory, isn’t it? Load CSV data, then treat it like a regular table (even though it isn’t).</p>\n<p>What if we could do the same trick but with spreadsheets? If it’s possible for CSV then it should be possible for XLSX and XLS files. We will write a SQLite extension for exactly that purpose.</p>\n<h3>Project structure</h3>\n<p>SQLite has the ability to load extensions as dynamic libraries. The library must declare an entry point which is called when the extension is loaded. Let’s create a Rust project named xlite and specify crate type to be dynamic library:</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">package</span><span class=\"token punctuation\">]</span>\n<span class=\"token key property\">name</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"xlite\"</span>\n<span class=\"token key property\">version</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"0.1.0\"</span>\n<span class=\"token key property\">edition</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"2021\"</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">lib</span><span class=\"token punctuation\">]</span>\n<span class=\"token key property\">crate-type</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"cdylib\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Running <code class=\"language-text\">cargo build</code> on this project will produce a dynamic library with one of the following filenames depending on your operation system: <code class=\"language-text\">libxlite.so</code>, <code class=\"language-text\">libxlite.dylib</code>, <code class=\"language-text\">xlite.dll</code>. The filenames are important because SQLite will use them to figure out the name of the entry point function (we will discuss that function next).</p>\n<p>Different languages have different libraries and APIs to load SQLite extensions. For simplicity and portability we will use <em>Command Line Shell For SQLite</em> now and further to test our extension. Now let’s load the extension (assuming you have <code class=\"language-text\">libxlite.so</code> in your current directory):</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">sqlite3\n<span class=\"token operator\">></span> .load <span class=\"token string\">'libxlite'</span></code></pre></div>\n<p>This command will tell SQLite to look for a dynamic library called <code class=\"language-text\">libxlite.so</code>. In that file SQLite will try to find a function named <code class=\"language-text\">sqlite3_xlite_init</code>. It’s fairly easy to see the pattern here: <code class=\"language-text\">sqlite3_{EXTENSION_NAME}_init</code> is the name of the function.</p>\n<p>Naturally, the above command will fail with error: we have not yet defined the entry point. We will work on it shortly but before we do let’s mention one important detail: writing bindings for C libraries manually is a long and error-prone task, that is why we are going to delegate it to an automatic toolkit called <code class=\"language-text\">rust-bindgen</code>. If you are interested in how this toolkit works I recommend checking out <a href=\"https://rust-lang.github.io/rust-bindgen/\">their documentation</a>. From now, I will assume that we generated <a href=\"https://github.com/x2bool/xlite/blob/master/src/sqlite.rs\">Rust FFI code</a> for <a href=\"https://github.com/x2bool/xlite/blob/master/src/sqlite.h\">sqlite.h</a> - it will be widely used in our project.</p>\n<p>You will often see the <code class=\"language-text\">no_mangle</code> and <code class=\"language-text\">repr</code> attributes in the code, this is also due to FFI and the need to keep memory layout the same as in C.</p>\n<h3>Entry point and modules</h3>\n<p>We already discussed that SQLite will look for a function with a specific name in the library. Now we’ll talk about how this function looks and what we could do with it.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">sqlite3_xlite_init</span><span class=\"token punctuation\">(</span>\n   db<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3<span class=\"token punctuation\">,</span>\n   pz_err_msg<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> c_char<span class=\"token punctuation\">,</span>\n   p_api<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_api_routines<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>The function takes a pointer to a database instance, a pointer to an error message and a pointer to so called api routines. The latter parameter is the most interesting to us: it contains routines that can be used to extend SQLite with new modules, functions and other arguably less common features such as collations and virtual file systems.</p>\n<p>Before we can create and register our module we need to write some tricky code. Let me explain: there is a macro called <code class=\"language-text\">SQLITE_EXTENSION_INIT2</code>, and SQLite demands that we call it before initializing the extension. Doing this trivial in C but we can’t call the macro from Rust, so instead we are going to replicate its behavior.</p>\n<p>First of all we will define a global variable to hold an sqlite3_api_routines instance with a specific name.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">mut</span> sqlite3_api<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_api_routines <span class=\"token operator\">=</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>ptr<span class=\"token punctuation\">::</span></span><span class=\"token function\">null_mut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Then, before doing any other work this global variable must be assigned:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">// inside sqlite3_xlite_init</span>\nsqlite3_api <span class=\"token operator\">=</span> p_api<span class=\"token punctuation\">;</span></code></pre></div>\n<p>After this, we can use the global variable to access routines. It is a somewhat unusual piece of code for Rust but it has to be written in order for our extension to work properly.</p>\n<p>Now, let’s actually create our module.</p>\n<p>Remember the CSV extension and its syntax for defining virtual tables? We will adapt it for our extension and highlight the important bits.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> VIRTUAL <span class=\"token keyword\">TABLE</span> xlsx_data <span class=\"token keyword\">USING</span> xlite<span class=\"token punctuation\">(</span>\n    FILENAME<span class=\"token operator\">=</span><span class=\"token string\">'/path/to/file.xlsx'</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The <code class=\"language-text\">CREATE VIRTUAL TABLE</code> syntax tells SQLite to use the module defined in the <code class=\"language-text\">USING</code> part of this statement. As we can see we named our module xlite. The next important piece of data is the FILENAME parameter, we’ll need it later. For now it is important to understand that virtual tables are created and managed by modules.</p>\n<p>So let’s create and register our module. One way to do it would be defining a structure to encapsulate required data. Strictly speaking, doing this is optional for simple modules that do not carry additional data (such as ours), but in this case we would like to store the name of our module along with the structure for convenience.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[repr(C)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Module</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// must be at the beginning</span>\n   base<span class=\"token punctuation\">:</span> sqlite3_module<span class=\"token punctuation\">,</span>\n   name<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'static</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>It is important to keep the base <code class=\"language-text\">sqlite3_module</code> structure as the first field in our newly-defined structure: in that way SQLite won’t notice the difference when we pass the pointer to our struct instead of the base <code class=\"language-text\">sqlite3_module</code> struct. Also layout in the memory will be exactly the same except for the additional name field at the end. The same technique will be applied for <code class=\"language-text\">sqlite3_vtab</code> and <code class=\"language-text\">sqlite3_vtab_cursor</code> structs as we’ll see later.</p>\n<p>Now we’ll need an instance of our module. Let’s create it. The simplest way to achieve this is to define a constant which is going to live as long as our extension is loaded to the memory.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">const</span> <span class=\"token constant\">XLITE_MODULE</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Module</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Module</span> <span class=\"token punctuation\">{</span>\n   base<span class=\"token punctuation\">:</span> sqlite3_module <span class=\"token punctuation\">{</span>\n       iVersion<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n       xCreate<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_create<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xConnect<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_connect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xBestIndex<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_best_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xDisconnect<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_disconnect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xDestroy<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_destroy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xOpen<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_open<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xClose<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_close<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xFilter<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_filter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xNext<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xEof<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_eof<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xColumn<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_column<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xRowid<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x_rowid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       xUpdate<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xBegin<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xSync<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xCommit<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xRollback<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xFindFunction<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xRename<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xSavepoint<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xRelease<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xRollbackTo<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n       xShadowName<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n   name<span class=\"token punctuation\">:</span> <span class=\"token string\">b\"xlite\\0\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>As you can see the module is an entity that encapsulates a set of function pointers. Let’s describe them:</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">x_create</code></td>\n<td>called when SQLite asks our extension to create a virtual table. The function must execute routines to define a virtual table (described later in this article)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_connect</code></td>\n<td>for our purposes is exactly the same as  x_create  (our extension will be readonly and won’t have a backing storage)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_destroy</code></td>\n<td>called when a table is being dropped. This is the place where resources allocated during  x_create  should be deallocated</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_disconnect</code></td>\n<td>for our purposes is the same as  x_destroy</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_open</code></td>\n<td>creates a cursor for reading data for a given virtual table</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_close</code></td>\n<td>closes a cursor previously opened by  x_open</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_next</code></td>\n<td>advances a cursor forward to a next row</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_eof</code></td>\n<td>checks if a cursor advanced beyond the last row and cannot produce more rows</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_column</code></td>\n<td>called when SQLite asks for the data inside current row and column N</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">x_rowid</code></td>\n<td>provides a stable identifier for current row</td>\n</tr>\n</tbody>\n</table>\n<p>There are also <code class=\"language-text\">x_best_index</code> and <code class=\"language-text\">x_filter</code> but our implementation will just provide empty stubs for these functions.</p>\n<p>Now we have the module and it should be registered with the <code class=\"language-text\">create_module</code> routine.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token constant\">XLITE_MODULE</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p_api<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>create_module<span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n   db<span class=\"token punctuation\">,</span>\n   name<span class=\"token punctuation\">.</span><span class=\"token function\">as_ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> c_char<span class=\"token punctuation\">,</span>\n   <span class=\"token operator\">&amp;</span><span class=\"token constant\">XLITE_MODULE</span> <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">Module</span> <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> sqlite3_module<span class=\"token punctuation\">,</span>\n   <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>ptr<span class=\"token punctuation\">::</span></span><span class=\"token function\">null_mut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In this code, we cast the module reference to a pointer and then cast it to <code class=\"language-text\">sqlite3_module</code> pointer. This is a valid code thanks to the “base struct is the first field in the derived struct” rule.</p>\n<h3>Virtual table</h3>\n<p>To connect together everything we learned so far and understand the lifecycle of a virtual table we will write a sequence of SQL statements and corresponding functions (using pseudocode). Let’s examine the lifecycle of a virtual table with 2 columns and 2 rows:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> VIRTUAL <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">-- x_create() -> VirtualTable</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">-- x_open(VirtualTable) -> VirtualCursor</span>\n\n<span class=\"token comment\">-- x_eof(VirtualCursor) -> false</span>\n<span class=\"token comment\">-- x_column(VirtualCursor, 1) -> [0,0]</span>\n<span class=\"token comment\">-- x_column(VirtualCursor, 2) -> [0,1]</span>\n<span class=\"token comment\">-- x_next(VirtualCursor)</span>\n<span class=\"token comment\">-- x_eof(VirtualCursor) -> false</span>\n<span class=\"token comment\">-- x_column(VirtualCursor, 1) -> [1,0]</span>\n<span class=\"token comment\">-- x_column(VirtualCursor, 2) -> [1,1]</span>\n<span class=\"token comment\">-- x_next(VirtualCursor)</span>\n<span class=\"token comment\">-- x_eof(VirtualCursor) -> true</span>\n\n<span class=\"token comment\">-- x_close(VirtualCursor)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token comment\">-- x_destroy(VirtualTable)</span></code></pre></div>\n<p>This can be summarized as: a module creates a virtual table using arguments provided to the <code class=\"language-text\">CREATE VIRTUAL TABLE</code> statement, <code class=\"language-text\">SELECT</code> query tells the module to create a cursor for the table, this cursor is then used to read all data row by row requesting selected columns.</p>\n<p>When it comes to the management of virtual tables these two functions must be implemented: <code class=\"language-text\">x_create</code> and <code class=\"language-text\">x_destroy</code>. Actually, there are also <code class=\"language-text\">x_connect</code> and <code class=\"language-text\">x_disconnect</code> but we won’t spend time implementing them, these functions are only used in advanced scenarios (if we had some kind of backing storage for our data that could be initialized only once and then reused in some way.)</p>\n<p>We will define a struct to hold the data for our virtual table:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[repr(C)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">VirtualTable</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// must be at the beginning</span>\n   base<span class=\"token punctuation\">:</span> sqlite3_vtab<span class=\"token punctuation\">,</span>\n   manager<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Arc</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Mutex</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">DataManager</span><span class=\"token operator\">>></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This should look familiar. The struct holds SQLite’s base struct called <code class=\"language-text\">sqlite3_vtab</code> as the first field, and then adds arbitrary data at the end (in this case the data is another struct from our domain model called <code class=\"language-text\">DataManager</code>).</p>\n<p>Now we will look at the actual <code class=\"language-text\">x_create</code> method implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_create</span><span class=\"token punctuation\">(</span>\n   db<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3<span class=\"token punctuation\">,</span>\n   _p_aux<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> c_void<span class=\"token punctuation\">,</span>\n   argc<span class=\"token punctuation\">:</span> c_int<span class=\"token punctuation\">,</span>\n   argv<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> c_char<span class=\"token punctuation\">,</span>\n   pp_vtab<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab<span class=\"token punctuation\">,</span>\n   pz_err<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> c_char<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>Let’s see what important parameters are passed into this function.</p>\n<p>A virtual table can accept arguments when it is created (such is the <code class=\"language-text\">FILENAME</code> argument). So <code class=\"language-text\">argc</code> is the number of such arguments and <code class=\"language-text\">argv</code> is an array of actual argument strings. This info will be used to parse and extract data from the passed options.</p>\n<p>The next important argument is <code class=\"language-text\">pp_vtab</code>. We should assign the instance of our virtual table to this pointer, but before we do that SQLite demands that we declare a table using the global routines object we defined earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> sql <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CREATE TABLE sheet(A,B,C)\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> cstr <span class=\"token operator\">=</span> <span class=\"token class-name\">CString</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>sql<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>api<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>declare_vtab<span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">,</span> cstr<span class=\"token punctuation\">.</span><span class=\"token function\">as_ptr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> _<span class=\"token punctuation\">)</span></code></pre></div>\n<p>This is a simplified version of what is actually done, the real implementation dynamically constructs a SQL statement depending on which columns are provided by an XLS file or by <code class=\"language-text\">RANGE</code> option. What is important here: we allocate a string with a <code class=\"language-text\">CREATE TABLE</code> statement that defines the structure of the table, then the string is turned into a pointer and passed to the <code class=\"language-text\">declare_vtab</code> routine.</p>\n<p>Now we will instantiate the virtual table, and assign the resulting pointer:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> p_new<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Box</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">VirtualTable</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Box</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">VirtualTable</span> <span class=\"token punctuation\">{</span>\n   base<span class=\"token punctuation\">:</span> sqlite3_vtab <span class=\"token punctuation\">{</span>\n       pModule<span class=\"token punctuation\">:</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>ptr<span class=\"token punctuation\">::</span></span><span class=\"token function\">null_mut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       nRef<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n       zErrMsg<span class=\"token punctuation\">:</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>ptr<span class=\"token punctuation\">::</span></span><span class=\"token function\">null_mut</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n   manager<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Arc</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Mutex</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>manager<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">*</span>pp_vtab <span class=\"token operator\">=</span> <span class=\"token class-name\">Box</span><span class=\"token punctuation\">::</span><span class=\"token function\">into_raw</span><span class=\"token punctuation\">(</span>p_new<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The code above allocates memory for the <code class=\"language-text\">VirtualTable</code> struct on the heap then leaks it using the <code class=\"language-text\">into_raw</code> function preventing automatic deallocation. Finally the result is casted to the <code class=\"language-text\">sqlite3_vtab</code> pointer.</p>\n<p>This is it, we implemented everything that should be implemented inside the <code class=\"language-text\">x_create</code> function. Now it’s time to write the <code class=\"language-text\">x_destroy</code> function:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_destroy</span><span class=\"token punctuation\">(</span>p_vtab<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>As we can see the function takes a single pointer to <code class=\"language-text\">sqlite3_vab</code>. Looks simple, and the implementation is simple too:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> table <span class=\"token operator\">=</span> <span class=\"token class-name\">Box</span><span class=\"token punctuation\">::</span><span class=\"token function\">from_raw</span><span class=\"token punctuation\">(</span>p_vtab <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> <span class=\"token class-name\">VirtualTable</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">drop</span><span class=\"token punctuation\">(</span>table<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We cast the pointer to a <code class=\"language-text\">VirtualTable</code> pointer, then call the <code class=\"language-text\">from_raw</code> function to construct a <code class=\"language-text\">Box</code> from the raw pointer. In a sense this is a step to reverse leaking of the allocated memory. Calling the <code class=\"language-text\">drop</code> function is not strictly necessary, and Rust would do this for us as a part of deallocating the box.</p>\n<h3>Cursor</h3>\n<p>The last important entity we will describe is the cursor. This entity is very similar to the concept of iterators. At least it is okay to think about them in this way when things are simple: there are no writes (only reads), no locks, no transactions and so on.</p>\n<p>The cursor is defined in the following way:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[repr(C)]</span>\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">VirtualCursor</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// must be at the beginning</span>\n   base<span class=\"token punctuation\">:</span> sqlite3_vtab_cursor<span class=\"token punctuation\">,</span>\n   reader<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Arc</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Mutex</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">DataReader</span><span class=\"token operator\">>></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We will omit the definition of <code class=\"language-text\">DataReader</code> structure. For now, we can think about it as a wrapper around an XLS file that can do the dirty work of actually reading data from Excel cells.</p>\n<p>As always, there must be a place where a struct is created. For the cursor that place is <code class=\"language-text\">x_open</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_open</span><span class=\"token punctuation\">(</span>\n   p_vtab<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab<span class=\"token punctuation\">,</span>\n   pp_cursor<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab_cursor<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>From this definition we can see that this function must assign the <code class=\"language-text\">pp_cursor</code> pointer. At this point we already know that we can instantiate and cast our struct to a pointer of a base struct type and we do exactly that inside the body of this function.</p>\n<p>Now let’s briefly examine other functions related to cursors.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_close</span><span class=\"token punctuation\">(</span>p_cursor<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab_cursor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>Earlier we did something similar to the <code class=\"language-text\">x_close</code> function. This function downcasts the pointer to the derived struct bringing data from unsafe space to the memory managed by Rust. Then the cursor is dropped.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_next</span><span class=\"token punctuation\">(</span>p_cursor<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab_cursor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>The next function is <code class=\"language-text\">x_next</code> (the pun is intended). It takes a cursor as an argument and mutates it by advancing the internal pointer to the next row.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_eof</span><span class=\"token punctuation\">(</span>p_cursor<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab_cursor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>This function is very simple. The <code class=\"language-text\">x_eof</code> checks if the cursor was moved beyond the last row in a data set and cannot be advanced further.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">x_column</span><span class=\"token punctuation\">(</span>\n    p_cursor<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_vtab_cursor<span class=\"token punctuation\">,</span>\n    p_context<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> sqlite3_context<span class=\"token punctuation\">,</span>\n    column<span class=\"token punctuation\">:</span> c_int<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> c_int</code></pre></div>\n<p>The <code class=\"language-text\">x_column</code> function is the most interesting function that deals with a cursor. Its job is to return data for a requested column at the current row. There are many routines that can be used to return data: <code class=\"language-text\">result_text</code>, <code class=\"language-text\">result_int</code>, <code class=\"language-text\">result_double</code>, <code class=\"language-text\">result_null</code> and <code class=\"language-text\">result_blob</code>. You probably already guessed that they are used depending on the results data type.</p>\n<p>Some of these routines are more interesting than others: there are occasions when data has to be allocated at the heap. In such cases we also pass a destructor function that will be called when SQLite decides it does not need the value anymore. Let’s look at an example with <code class=\"language-text\">result_text</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> cstr <span class=\"token operator\">=</span> <span class=\"token class-name\">CString</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> len <span class=\"token operator\">=</span> cstr<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> raw <span class=\"token operator\">=</span> cstr<span class=\"token punctuation\">.</span><span class=\"token function\">into_raw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">destructor</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> c_void<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token function\">drop</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CString</span><span class=\"token punctuation\">::</span><span class=\"token function\">from_raw</span><span class=\"token punctuation\">(</span>raw <span class=\"token keyword\">as</span> <span class=\"token operator\">*</span><span class=\"token keyword\">mut</span> c_char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>api<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>result_text<span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n   p_context<span class=\"token punctuation\">,</span>\n   raw<span class=\"token punctuation\">,</span>\n   len <span class=\"token keyword\">as</span> c_int<span class=\"token punctuation\">,</span>\n   <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>destructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In this example a <code class=\"language-text\">CString</code> is used and it allocates memory on the heap. In order to deallocate it we also provide a destructor function.</p>\n<h3>Conclusion</h3>\n<p>In this article I tried to describe the most important steps for creating a SQLite extension in Rust.</p>\n<p>Needless to say, this article is not a complete guide on extending SQLite. I tried to cover parts that appeared essential and interesting. It’s always a trade-off when you write technical articles: you want to cover more and in more detail but you have to set some boundaries otherwise the article will be infinite in size and complexity.</p>\n<p>Anyway, the code from this article is taken from the <a href=\"https://github.com/x2bool/xlite\">open-source project</a>, and I hope the reader can always go to the repository for more detail if there is need for it.</p>\n<p>And, of course, bug-reports and other forms of feedback are always welcome.</p>","frontmatter":{"title":"Extending SQLite with Rust to support Excel files as virtual tables","date":"July 17, 2022","description":"How to use Rust to create loadable SQLite extensions"}},"previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello, World!"}},"next":null},"pageContext":{"id":"aed3217f-255a-5e75-a54d-5ad6833e0452","previousPostId":"145b45a6-2137-54e4-a6ab-303e4c2b987c","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}